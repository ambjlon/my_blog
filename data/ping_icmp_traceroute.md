### ping命令原理
ping命令是使用icmp协议实现的.  
ip层协议包括ip协议 arp/arpr协议 icmp协议. icmp协议使用ip协议进行报文传送, 也就是icmp报文是ip报文的数据部分, 和tcp/udp协议的报文处的位置一样. 然而, arp/arpr协议不是寄托在ip协议上的, 是独立的**局域网**协议. 因为icmp协议是ip协议的得力辅助协议, 包括在ip协议异常的时候进行差错报告等等, 所以我们人为的认为icmp协议是ip层的协议.  
icmp协议包括差错报文和询问报文. 一般情况下, **差错报文是在ip报文有异常的时候主动触发的, 不能对差错报文进行回复**; 询问报文多是先由源主机向目标主机主动发起询问, 然后目标主机予以回复.  
ping命令使用icmp协议的询问报文. 其中标示符一般是进程号, 序号递增. 还可以在报文尾部填充任意数据.

### ping命令使用
linux下和windows下ping命令参数含义**不尽相同**. 主要学习linux ping命令的参数.  
ping命令的参数:

+ -s 设置数据包大小, 实际上是调整填充数据的大小, 当设置-s 1400的时候, 实际发送的包的大小是1410, 因为icmp报文本身还有头部的10字节大小的数据. 操作系统会限制数据包的大小的, 或者remote主机也对ping数据包的大小做出限制, 所以不能设置发送数据包太大的.
+ -i 设置ping的请求时间间隔. 每个系统的最小时间间隔不同. mac上是0.1s, centos是0.2s.
+ -f 参数表示极限flood, 但是ping命令中并没找到这个参数.
+ -t 参数设置TTL值, linux系统测试这个参数不起作用... mac中对应的是-m参数.

各个版本的ping的参数不尽相同, 其他参数暂不做学习.

#### ping输出中的TTL
ping的输出中有个ttl数据项, **表示还剩余几跳(路由跳转)可以用**. 若是系统默认的TTl=64, 当ttl数据项是61的时候, 表示已经跳了3次路由. linux系统的默认TTL一般是64, 通过cat /proc/sys/net/ipv4/ip_default_ttl可以查看.
#### ping不适合网络上传下载测速
ping命令专门用来测试时延. 用来测试网速并不太合适, 用ping估算的网速没有太大的参考意义, 因为发送的数据包的大小有上限, 不能行程连续的数据传输.
### traceroute命令原理
traceroute命令是通过设置IP数据包的TTL来实现的. IP数据包负载UDP或者ICMP.
一开始发送一个TTL为1的包，这样到达第一个路由器的时候就已经超时了，第一个路由器就发通知说包超时，这样就可以记录下 所经过的第一个路由器的IP。然后TTL加1，安全通过第一个路由器，而第二个路由器的的处理与第一个相同，丢包，发通知说包超时了，这样记录下第二个路 由器IP，由此可以一直进行下去，直到这个数据包到达目标主机，由此打印出所有经过的路由器。
使用UDP探测的话, 一般选择高端口, 目标路由器或主机一般不会使用这些端口, 万一使用, traceroute失效. 但是使用ICMP探测就没有这个问题了.

### traceroute命令使用

-w参数设定timewait时间

#### traceroute命令输出中的三个时间
traceroute的输出记过中有三个时间, 因为对每个路由节点, 默认是要发送三次请求的, 这三个时间是每次请求的耗时.

#### trace route命令 数据报文选择
linux环境下: -I指定使用ICMP做探测 -T指定使用TCP做探测, 还可以设置使用UDP, 设置探测使用的端口等等.(traceroute命令默认使用UDP做探测?)

### 参考:
+ http://blog.csdn.net/tigerjibo/article/details/7356936
+ http://www.cnblogs.com/scrat/archive/2012/08/02/2620163.html
+ http://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html
+ http://www.cnblogs.com/peida/archive/2013/03/06/2945407.html



