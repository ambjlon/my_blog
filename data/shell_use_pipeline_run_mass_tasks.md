使用shell编写程序的时候, 我们可以通过循环和nohup结合启动大量的后台进程.  有时需要启动的进程数会超过操作系统可以承受的上限. 比如, 通过hive客户端同时向hadoop提交大量的补数据的hql任务, 使用hive -e提交100个左右的任务机器就会卡死, 但是我们需要补数据的任务可能会有上千个. 此时, 我们需要控制同时启动的进程数不超过最大上限, 使得这些任务一波一波的逐渐完成.

## shell管道
+ shell的管道是用来进程间通信的.
+ 管道包括有名管道和匿名管道, 本文中主要在讲有名管道.
+ 通过mkfifo tmp创建一个叫做tmp的管道, 本地目录会出现一个叫做tmp的属性为"p"的文件. 
+ 对tmp的操作类似对文件的操作: 通过echo向管道写入内容echo "Happy new year\!">tmp; 通过read读取管道内容read x < tpm && echo \$x. 
+ 本地的tmp文件只是方便各个进程找到的标示, 不会存储任何数据, 数据的存储读取都是在内存区域进行的, 所以管道实际上可以说是一种内存文件. 
+ 管道和普通文件主要不同的地方在于管道中的内容只能被读取一次. 管道的写入和读取可以造成相关行为进程的阻塞, 达到类似生产者和消费者的效果.
+ **非常重要的一点**, 不能把管道理解为像内存队列堆栈那样的数据结构, **不是**每写入一次占用一个存储位置. 整个管道就是一个文件, 每次读取的内容随由读取进程控制. 只不过读取的时候不能随意定位, 只能读取最旧的内容.

## 使用管道控制进程并发
假设我们允许最多有40个进程同时运行. 首先建立一个管道, 向这个管道写入40行内容进行初始化(&后台运行40次). 然后每次要启动新进程之前都要去这个管道read, 能娶到一行那就启动一个新进程, 不能读取就阻塞在那里不启动新进程. 每个进程运行结束的时候, 通过echo向管道写入一行内容, 给接下来启动新进程创建机会~~  

    :::shell
    ##masterpro.sh
    temp_fifo_file=$$.info        #以当前进程号为临时管道取名
    mkfifo $temp_fifo_file        #创建临时管道
    exec 1988<>$temp_fifo_file    #把文件描述符1988绑定到管道，后续可以通过1988这个文件描述符对管道进行读写
    rm $temp_fifo_file            #清空管道内容    
    temp_thread=40                #同时并发的最大进程数
    for ((i=0;i<temp_thread;i++)) 
    do
        echo "a"                  #每行一个"a".
    done >&1988                   #将占位信息写入文件描述符为1988的管道.
    sh subprocess.sh              #fork子进程. 子进程会继承主进程的文件描述符资源.
    exec 1988>&-                  #关闭主进程的文件描述, 不影响子进程读写管道内容. 文件描述符是每个进程专有的.
    
    ##subpro.sh
    for((i=1;i<=10;i++))
    do
        read
        {
            [do something]       #此处不要后台运行!!
            echo "a" > &1988
        }&                       #后台执行
    done < &1988
    wait                         #等待前面启动的所有后台进程执行完. wait只等待本进程中直接fork的后台子进程, 不会等待子进程中再继续fork的子进程! 
    exec  1988>&-
        
read命令默认是以换行为分隔符的. echo -e "Happy new year\c" > tmp, 这样故意去掉末尾的换行符会导致读取不到任何内容.

## 参考
1. [SHELL中的使用fifo管道实现多进程运行效率](http://blog.csdn.net/wqq_721/article/details/7968099)
2. [Linux Shell多进程并发以及并发数控制](http://ouyangyewei.me/2016/01/10/linux-shell-parallel-control/)
3. [bash shell必须掌握的命令--exec命令](http://blog.chinaunix.net/uid-346158-id-2131173.html)
4. [Linux的进程间通信 － 管道](http://liwei.life/2016/07/18/pipe/)
5. [Linux Shell学习：使用read从标准输入中读取一行](http://www.programgo.com/article/13462643399/)
